#!/usr/bin/env bash
#
# claude-yolo: Run Claude Code in an isolated Docker container with --dangerously-skip-permissions
#
# Usage:
#   claude-yolo [--yolo] [--strategy <name>] [--build] [--verbose] [--chrome] [claude args...]
#
# Flags:
#   --yolo              Run in Docker container with full permission bypass
#   --strategy <name>   Skip auto-detection, use specified strategy (rails, android, ...)
#   --build             Force rebuild the Docker image before running
#   --verbose           Show raw Docker build output instead of spinner
#   --chrome            Enable Chrome DevTools MCP server for browser control
#
# Without --yolo, passes through to the native claude command.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_DIR="$(dirname "$SCRIPT_DIR")"
STRATEGIES_DIR="$REPO_DIR/strategies"

# Chrome CDP port for remote debugging
CDP_PORT=9222

# Stale image threshold (days)
STALE_IMAGE_DAYS=14

########################################
# Color / glyph system
########################################

if [[ -t 2 ]]; then
  BOLD='\033[1m' DIM='\033[2m' RESET='\033[0m'
  GREEN='\033[32m' CYAN='\033[36m' YELLOW='\033[33m' RED='\033[31m'
else
  BOLD='' DIM='' RESET='' GREEN='' CYAN='' YELLOW='' RED=''
fi

########################################
# Output helpers
########################################

BOX_WIDTH=46

header() {
  echo -e "  ${DIM}┌${RESET} ${BOLD}claude·yolo${RESET} ${DIM}$(printf '─%.0s' $(seq 1 $((BOX_WIDTH - 14))))${RESET}" >&2
}

footer() {
  echo -e "  ${DIM}└$(printf '─%.0s' $(seq 1 $((BOX_WIDTH - 1))))${RESET}" >&2
}

info() {
  echo -e "  ${CYAN}→${RESET} $*" >&2
}

success() {
  echo -e "  ${GREEN}✔${RESET} $*" >&2
}

fail() {
  echo -e "  ${RED}✘${RESET} $*" >&2
}

warn() {
  echo -e "  ${YELLOW}○${RESET} $*" >&2
}

dim() {
  echo -e "  ${DIM}$*${RESET}" >&2
}

########################################
# Git / path helpers
########################################

get_worktree_path() {
  git rev-parse --show-toplevel 2>/dev/null || pwd
}

path_hash() {
  if command -v md5 &>/dev/null; then
    echo -n "$1" | md5 | cut -c1-8
  elif command -v md5sum &>/dev/null; then
    echo -n "$1" | md5sum | cut -c1-8
  else
    echo -n "$1" | shasum | cut -c1-8
  fi
}

########################################
# Docker helpers
########################################

check_docker() {
  if ! command -v docker &>/dev/null; then
    fail "Docker is not installed. Install Docker Desktop and try again."
    exit 1
  fi

  if ! docker info &>/dev/null; then
    fail "Docker is not running. Start Docker Desktop and try again."
    exit 1
  fi
}

image_exists() {
  local image="$1"
  docker image inspect "${image}:latest" &>/dev/null
}

find_running_container() {
  local hash="$1"
  docker ps --format '{{.Names}}' 2>/dev/null | grep "^claude-yolo-${hash}-" | head -1
}

container_uptime() {
  local name="$1"
  local started_at
  started_at=$(docker inspect --format '{{.State.StartedAt}}' "$name" 2>/dev/null) || return 1

  local start_epoch now_epoch
  local ts
  ts=$(echo "$started_at" | cut -d. -f1)
  if date -juf "%Y-%m-%dT%H:%M:%S" "$ts" +%s &>/dev/null 2>&1; then
    start_epoch=$(date -juf "%Y-%m-%dT%H:%M:%S" "$ts" +%s)
  else
    start_epoch=$(date -d "$started_at" +%s 2>/dev/null) || return 1
  fi
  now_epoch=$(date +%s)

  local diff=$(( now_epoch - start_epoch ))
  local hours=$(( diff / 3600 ))
  local minutes=$(( (diff % 3600) / 60 ))

  if [[ $hours -gt 0 ]]; then
    echo "${hours}h ${minutes}m"
  else
    echo "${minutes}m"
  fi
}

image_age_days() {
  local image="$1"
  local created_at
  created_at=$(docker inspect --format '{{.Created}}' "${image}:latest" 2>/dev/null) || return 1

  local ts created_epoch now_epoch
  ts=$(echo "$created_at" | cut -d. -f1)
  if date -juf "%Y-%m-%dT%H:%M:%S" "$ts" +%s &>/dev/null 2>&1; then
    created_epoch=$(date -juf "%Y-%m-%dT%H:%M:%S" "$ts" +%s)
  else
    created_epoch=$(date -d "$created_at" +%s 2>/dev/null) || return 1
  fi
  now_epoch=$(date +%s)

  echo $(( (now_epoch - created_epoch) / 86400 ))
}

########################################
# Chrome CDP (used by multiple strategies)
########################################

cdp_available() {
  curl -s --connect-timeout 1 "http://localhost:${CDP_PORT}/json/version" &>/dev/null
}

ensure_chrome() {
  if cdp_available; then
    return 0
  fi

  "$REPO_DIR/scripts/start-chrome.sh" || {
    fail "Failed to start Chrome"
    exit 1
  }

  local attempts=0
  while ! cdp_available && [[ $attempts -lt 20 ]]; do
    sleep 0.5
    attempts=$((attempts + 1))
  done

  if ! cdp_available; then
    fail "Chrome CDP not available after startup attempt"
    exit 1
  fi
}

########################################
# GitHub token detection & validation
########################################

_GITHUB_TOKEN=""
_GITHUB_TOKEN_SOURCE=""

parse_env_file() {
  local file="$1"
  local key line token
  for key in GH_TOKEN GITHUB_TOKEN; do
    line=$(grep -E "^(export )?${key}=" "$file" 2>/dev/null | head -1 || true)
    if [[ -n "$line" ]]; then
      token=$(echo "$line" | sed -E "s/^(export )?${key}=//; s/^['\"]//; s/['\"]$//" | tr -d '[:space:]')
      if [[ -n "$token" ]]; then
        echo "$token"
        return 0
      fi
    fi
  done
  return 1
}

find_github_token() {
  local worktree_path="$1"

  if [[ -n "${GH_TOKEN:-}" ]]; then
    _GITHUB_TOKEN="$GH_TOKEN"
    _GITHUB_TOKEN_SOURCE="GH_TOKEN env var"
    return 0
  fi

  if [[ -n "${GITHUB_TOKEN:-}" ]]; then
    _GITHUB_TOKEN="$GITHUB_TOKEN"
    _GITHUB_TOKEN_SOURCE="GITHUB_TOKEN env var"
    return 0
  fi

  local token=""

  if [[ -f "${worktree_path}/.env" ]]; then
    token=$(parse_env_file "${worktree_path}/.env") || true
    if [[ -n "$token" ]]; then
      _GITHUB_TOKEN="$token"
      _GITHUB_TOKEN_SOURCE="${worktree_path}/.env"
      return 0
    fi
  fi

  if [[ -f "${HOME}/.env" ]]; then
    token=$(parse_env_file "${HOME}/.env") || true
    if [[ -n "$token" ]]; then
      _GITHUB_TOKEN="$token"
      _GITHUB_TOKEN_SOURCE="$HOME/.env"
      return 0
    fi
  fi

  local gh_config="${XDG_CONFIG_HOME:-$HOME/.config}/gh/hosts.yml"
  if [[ -f "$gh_config" ]]; then
    token=$(grep 'oauth_token:' "$gh_config" 2>/dev/null | head -1 | sed 's/.*oauth_token:[[:space:]]*//' | tr -d '[:space:]' || true)
    if [[ -n "$token" ]]; then
      _GITHUB_TOKEN="$token"
      _GITHUB_TOKEN_SOURCE="$gh_config"
      return 0
    fi
  fi

  # Try gh CLI keyring (macOS Keychain, etc.)
  if command -v gh &>/dev/null; then
    token=$(gh auth token 2>/dev/null) || true
    if [[ -n "$token" ]]; then
      _GITHUB_TOKEN="$token"
      _GITHUB_TOKEN_SOURCE="gh auth token (keyring)"
      return 0
    fi
  fi

  return 1
}

validate_github_token() {
  local token="$1"
  local http_code
  http_code=$(curl -s -o /dev/null -w "%{http_code}" \
    --connect-timeout 5 --max-time 10 \
    -H "Authorization: token $token" \
    https://api.github.com/user 2>/dev/null) || return 1
  [[ "$http_code" == "200" ]]
}

ensure_github_token() {
  local worktree_path="$1"

  if [[ -n "${CLAUDE_YOLO_NO_GITHUB:-}" ]]; then
    dim "GitHub token check skipped (CLAUDE_YOLO_NO_GITHUB)"
    return 0
  fi

  if ! find_github_token "$worktree_path"; then
    fail "GitHub token not found"
    echo "" >&2
    dim "Searched:"
    dim "  • GH_TOKEN environment variable"
    dim "  • GITHUB_TOKEN environment variable"
    dim "  • ${worktree_path}/.env"
    dim "  • ~/.env"
    dim "  • ~/.config/gh/hosts.yml"
    dim "  • gh auth token (keyring)"
    echo "" >&2
    dim "Set one with:"
    dim "  export GH_TOKEN=ghp_your_token_here"
    echo "" >&2
    dim "Or skip this check entirely:"
    dim "  export CLAUDE_YOLO_NO_GITHUB=1"
    exit 1
  fi

  if ! validate_github_token "$_GITHUB_TOKEN"; then
    fail "GitHub token invalid (${_GITHUB_TOKEN_SOURCE})"
    dim "Verify: GH_TOKEN=\$GH_TOKEN gh auth status"
    exit 1
  fi

  success "GitHub token ${DIM}(${_GITHUB_TOKEN_SOURCE})${RESET}"
}

########################################
# Ruby version detection (for Rails)
########################################

detect_ruby_version() {
  local worktree_path="$1"

  if [[ -f "${worktree_path}/.ruby-version" ]]; then
    cat "${worktree_path}/.ruby-version" | tr -d '[:space:]'
    return 0
  fi

  if [[ -f "${worktree_path}/.tool-versions" ]]; then
    local ver
    ver=$(grep "^ruby " "${worktree_path}/.tool-versions" 2>/dev/null | awk '{print $2}' | head -1)
    if [[ -n "$ver" ]]; then
      echo "$ver"
      return 0
    fi
  fi

  if [[ -f "${worktree_path}/Gemfile" ]]; then
    local ver
    ver=$(grep -E "^ruby ['\"]" "${worktree_path}/Gemfile" 2>/dev/null | \
      sed -E "s/ruby ['\"]([^'\"]+)['\"].*/\1/" | head -1)
    if [[ -n "$ver" ]]; then
      echo "$ver"
      return 0
    fi
  fi

  echo "3.3.0"
}

########################################
# Environment detection
########################################

list_strategies() {
  for dir in "$STRATEGIES_DIR"/*/; do
    if [[ -f "${dir}detect.sh" ]]; then
      basename "$dir"
    fi
  done
}

run_detection() {
  local worktree_path="$1"
  local results=()

  for strategy in $(list_strategies); do
    local output
    output=$("$STRATEGIES_DIR/$strategy/detect.sh" "$worktree_path" 2>/dev/null) || continue
    local confidence evidence
    confidence=$(echo "$output" | grep '^CONFIDENCE:' | cut -d: -f2 || true)
    evidence=$(echo "$output" | grep '^EVIDENCE:' | cut -d: -f2- || true)

    if [[ "${confidence:-0}" -gt 0 ]]; then
      results+=("${confidence}:${strategy}:${evidence}")
    fi
  done

  if [[ ${#results[@]} -gt 0 ]]; then
    printf '%s\n' "${results[@]}" | sort -t: -k1 -rn
  fi
}

choose_strategy() {
  local worktree_path="$1"
  local detections
  detections=$(run_detection "$worktree_path")

  if [[ -n "$detections" ]]; then
    local count
    count=$(echo "$detections" | wc -l | tr -d ' ')
    local top_confidence top_strategy top_evidence
    top_confidence=$(echo "$detections" | head -1 | cut -d: -f1)
    top_strategy=$(echo "$detections" | head -1 | cut -d: -f2)
    top_evidence=$(echo "$detections" | head -1 | cut -d: -f3-)

    if [[ "$count" -eq 1 && "$top_confidence" -ge 80 ]]; then
      echo -e "  ${GREEN}●${RESET} Detected: ${BOLD}${top_strategy}${RESET} (${top_confidence}%)" >&2
      dim "  ${top_evidence}"
      echo "$top_strategy"
      return 0
    fi

    echo "" >&2
    echo -e "  Detected:" >&2
    local i=1
    while IFS=: read -r confidence strategy evidence; do
      local glyph color
      if [[ "$confidence" -ge 80 ]]; then
        glyph="●"
        color="$GREEN"
      else
        glyph="○"
        color="${DIM}${YELLOW}"
      fi
      printf "    ${BOLD}%d${RESET}  ${color}${glyph}${RESET} %-10s ${DIM}%3s%%${RESET}   ${DIM}%s${RESET}\n" \
        "$i" "$strategy" "$confidence" "$evidence" >&2
      ((i++))
    done <<< "$detections"
    printf "    ${BOLD}%d${RESET}  ○ %-10s        ${DIM}%s${RESET}\n" \
      "$i" "other" "see all supported / generate new" >&2
    echo "" >&2

    local choice
    read -p "  Press ENTER for ${top_strategy}, or select [1-${i}]: " choice >&2

    if [[ -z "$choice" ]]; then
      echo "$top_strategy"
      return 0
    fi

    if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$i" ]]; then
      fail "Invalid selection: $choice"
      exit 1
    fi

    if [[ "$choice" -eq "$i" ]]; then
      choose_from_full_list "$worktree_path"
      return $?
    fi

    echo "$detections" | sed -n "${choice}p" | cut -d: -f2
    return 0
  fi

  choose_from_full_list "$worktree_path"
}

choose_from_full_list() {
  local worktree_path="$1"
  local strategies=()

  echo "" >&2
  warn "No environment auto-detected"
  echo "" >&2
  echo -e "  Select an environment:" >&2
  local i=1
  for strategy in $(list_strategies); do
    strategies+=("$strategy")
    local desc=""
    if [[ -f "$STRATEGIES_DIR/$strategy/description" ]]; then
      desc=$(cat "$STRATEGIES_DIR/$strategy/description" | tr -d '\n')
    fi
    printf "    ${BOLD}%d${RESET}  %-12s ${DIM}%s${RESET}\n" "$i" "$strategy" "$desc" >&2
    ((i++))
  done
  printf "    ${BOLD}%d${RESET}  %-12s ${DIM}%s${RESET}\n" "$i" "other" "generate prompt for new strategy" >&2
  echo "" >&2

  local choice
  read -p "  ▸ " choice >&2

  if ! [[ "$choice" =~ ^[0-9]+$ ]] || [[ "$choice" -lt 1 || "$choice" -gt "$i" ]]; then
    fail "Invalid selection: $choice"
    exit 1
  fi

  if [[ "$choice" -eq "$i" ]]; then
    generate_unknown_prompt "$worktree_path"
    echo "__unknown__"
    return 0
  fi

  echo "${strategies[$((choice - 1))]}"
}

generate_unknown_prompt() {
  local worktree_path="$1"

  local notable_files
  notable_files=$(cd "$worktree_path" && find . -maxdepth 3 \
    -name "*.json" -o -name "*.yaml" -o -name "*.yml" -o \
    -name "*.toml" -o -name "*.lock" -o -name "*.cfg" -o \
    -name "Makefile" -o -name "Dockerfile" -o -name "*.gemspec" -o \
    -name "*.csproj" -o -name "*.sln" -o -name "*.cabal" -o \
    -name "go.mod" -o -name "go.sum" -o \
    -name "Cargo.toml" -o -name "Cargo.lock" -o \
    -name "requirements.txt" -o -name "pyproject.toml" -o -name "setup.py" -o \
    -name "pom.xml" -o -name "build.gradle" -o -name "build.gradle.kts" -o \
    -name "mix.exs" -o -name "pubspec.yaml" -o -name "Package.swift" -o \
    -name "CMakeLists.txt" -o -name "Gemfile" -o \
    -name "package.json" -o -name "tsconfig.json" -o \
    -name "composer.json" -o -name "*.pro" -o \
    -name ".ruby-version" -o -name ".node-version" -o \
    -name ".python-version" -o -name ".tool-versions" \
    2>/dev/null | sort | head -40)

  echo "" >&2
  echo -e "  ${DIM}┌─${RESET} Copy this into Claude ${DIM}$(printf '─%.0s' $(seq 1 $((BOX_WIDTH - 25))))┐${RESET}" >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  I need you to create a new environment strategy for claude-yolo" >&2
  echo -e "  ${DIM}│${RESET}  (located at $REPO_DIR)." >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  The project at \"$worktree_path\" contains these notable files:" >&2
  echo -e "  ${DIM}│${RESET}" >&2
  while IFS= read -r f; do
    echo -e "  ${DIM}│${RESET}    $f" >&2
  done <<< "$notable_files"
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  Look at the existing strategies in strategies/rails/ and" >&2
  echo -e "  ${DIM}│${RESET}  strategies/android/ as reference. Each strategy needs 3 files:" >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  1. strategies/<name>/detect.sh" >&2
  echo -e "  ${DIM}│${RESET}  2. strategies/<name>/Dockerfile" >&2
  echo -e "  ${DIM}│${RESET}  3. strategies/<name>/entrypoint.sh" >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  Optional: strategies/<name>/platform" >&2
  echo -e "  ${DIM}│${RESET}  Optional: strategies/<name>/description (one-line summary)" >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}│${RESET}  Read the existing strategies first, then create the new one." >&2
  echo -e "  ${DIM}│${RESET}" >&2
  echo -e "  ${DIM}└$(printf '─%.0s' $(seq 1 $((BOX_WIDTH - 1))))┘${RESET}" >&2
}

########################################
# Image building
########################################

build_strategy_image() {
  local strategy="$1"
  local verbose="${2:-false}"
  local strategy_dir="$STRATEGIES_DIR/$strategy"
  local image_name="claude-yolo-${strategy}"

  [[ -d "$strategy_dir" ]] || { fail "Strategy not found: $strategy"; exit 1; }
  [[ -f "$strategy_dir/Dockerfile" ]] || { fail "No Dockerfile for strategy: $strategy"; exit 1; }

  local platform=""
  if [[ -f "$strategy_dir/platform" ]]; then
    platform=$(cat "$strategy_dir/platform" | tr -d '[:space:]')
  fi

  local -a build_cmd=(docker build)
  if [[ -n "$platform" ]]; then
    build_cmd+=(--platform "$platform")
  fi
  build_cmd+=(-t "${image_name}:latest" -f "${strategy_dir}/Dockerfile" "$strategy_dir")

  info "Building ${BOLD}${image_name}${RESET} (first run, may take a few minutes)"

  if [[ "$verbose" == true ]]; then
    DOCKER_BUILDKIT=1 "${build_cmd[@]}" || { fail "Build failed"; exit 1; }
  else
    local logfile
    logfile=$(mktemp /tmp/claude-yolo-build-XXXXXX)

    local spinner_chars='⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏'
    local build_start
    build_start=$(date +%s)
    local build_pid

    DOCKER_BUILDKIT=1 "${build_cmd[@]}" >"$logfile" 2>&1 &
    build_pid=$!

    while kill -0 "$build_pid" 2>/dev/null; do
      local elapsed=$(( $(date +%s) - build_start ))
      local idx=$(( elapsed % ${#spinner_chars} ))
      local char="${spinner_chars:$idx:1}"
      printf "\r  ${CYAN}%s${RESET} Building... ${DIM}%ds${RESET}  " "$char" "$elapsed" >&2
      sleep 0.2
    done

    local exit_code=0
    wait "$build_pid" || exit_code=$?
    printf "\r%*s\r" 40 "" >&2

    if [[ $exit_code -ne 0 ]]; then
      echo "" >&2
      fail "Build failed (see output below)"
      echo "" >&2
      cat "$logfile" >&2
      rm -f "$logfile"
      exit 1
    fi

    local total=$(( $(date +%s) - build_start ))
    rm -f "$logfile"
    success "Image ready (${total}s)"
  fi
}

########################################
# Container execution
########################################

run_with_strategy() {
  local strategy="$1"
  local container_name="$2"
  local verbose="$3"
  shift 3
  local claude_args=("$@")

  local worktree_path
  worktree_path=$(get_worktree_path)
  local hash
  hash=$(path_hash "$worktree_path")
  local image_name="claude-yolo-${strategy}"

  # Ensure image exists
  if ! image_exists "$image_name"; then
    build_strategy_image "$strategy" "$verbose"
  fi

  # Stale image warning
  local age
  age=$(image_age_days "$image_name" 2>/dev/null) || age=0
  if [[ "$age" -gt "$STALE_IMAGE_DAYS" ]]; then
    warn "Image built ${age} days ago — run ${BOLD}cc --yolo --build${RESET} to update"
  fi

  # Platform for docker run
  local platform=""
  if [[ -f "$STRATEGIES_DIR/$strategy/platform" ]]; then
    platform=$(cat "$STRATEGIES_DIR/$strategy/platform" | tr -d '[:space:]')
  fi

  # Common volumes
  local node_volume="claude-yolo-${hash}-node"

  # Ensure host .claude directory exists for bind mount
  mkdir -p "${HOME}/.claude"

  # Remove stopped container with the same name
  docker rm "$container_name" 2>/dev/null || true

  # Build the docker run command
  local -a docker_args=(
    docker run -it --rm
    --name "$container_name"
    --network=host
    -v "${worktree_path}:/workspace"
    -v "${HOME}/.claude:/home/claude/.claude"
    -v "${node_volume}:/workspace/node_modules"
    -e "CHROME_CDP_URL=http://localhost:${CDP_PORT}"
    -e "TERM=${TERM:-xterm-256color}"
    -e "COLORTERM=${COLORTERM:-}"
    -w /workspace
  )

  # GitHub token for gh CLI inside container
  if [[ -n "$_GITHUB_TOKEN" ]]; then
    docker_args+=(
      -e "GH_TOKEN=${_GITHUB_TOKEN}"
      -e "GITHUB_TOKEN=${_GITHUB_TOKEN}"
    )
  fi

  if [[ -n "$platform" ]]; then
    docker_args+=(--platform "$platform")
  fi

  # Mount git config read-only
  if [[ -f "${HOME}/.gitconfig" ]]; then
    docker_args+=(-v "${HOME}/.gitconfig:/home/claude/.gitconfig:ro")
  fi

  # Mount host CLAUDE.md read-only
  if [[ -f "${HOME}/.claude/CLAUDE.md" ]]; then
    docker_args+=(-v "${HOME}/.claude/CLAUDE.md:/home/claude/.claude/CLAUDE.md:ro")
  fi

  # Mount host settings read-only
  for settings_file in settings.json settings.local.json; do
    if [[ -f "${HOME}/.claude/${settings_file}" ]]; then
      docker_args+=(-v "${HOME}/.claude/${settings_file}:/home/claude/.claude/${settings_file}:ro")
    fi
  done

  # Mount host commands read-only
  if [[ -d "${HOME}/.claude/commands" ]]; then
    docker_args+=(-v "${HOME}/.claude/commands:/home/claude/.claude/commands:ro")
  fi

  # If workspace is a git worktree, mount the parent .git directory
  # so the gitdir path in the .git file resolves inside the container
  local git_file="${worktree_path}/.git"
  if [[ -f "$git_file" ]]; then
    local gitdir_path
    gitdir_path=$(sed -n 's/^gitdir: //p' "$git_file")
    if [[ -n "$gitdir_path" ]]; then
      local parent_git_dir
      parent_git_dir=$(cd "$worktree_path" && cd "$(dirname "$gitdir_path")" && cd .. && pwd)
      docker_args+=(-v "${parent_git_dir}:${parent_git_dir}")
    fi
  fi

  # Strategy-specific volumes and env vars
  local display_worktree="${worktree_path/#$HOME/\~}"
  case "$strategy" in
    rails)
      local ruby_version
      ruby_version=$(detect_ruby_version "$worktree_path")
      local gems_volume="claude-yolo-${hash}-gems"
      local rbenv_volume="claude-yolo-${hash}-rbenv"

      docker_args+=(
        -v "${gems_volume}:/home/claude/.gems"
        -v "${rbenv_volume}:/home/claude/.rbenv/versions"
        -e "RUBY_VERSION=${ruby_version}"
        -e "DB_HOST=host.docker.internal"
        -e "DB_USERNAME=postgres"
        -e "DB_PASSWORD=postgres"
      )

      info "Worktree  ${display_worktree}"
      info "Ruby ${ruby_version} · Postgres"
      ;;

    android)
      local gradle_volume="claude-yolo-${hash}-gradle"

      docker_args+=(
        -v "${gradle_volume}:/home/claude/.gradle"
        -e "ANDROID_DEVICE=${ANDROID_DEVICE:-}"
      )

      info "Worktree  ${display_worktree}"
      if [[ -n "${ANDROID_DEVICE:-}" ]]; then
        info "Device    ${ANDROID_DEVICE}"
      else
        info "Device    ${DIM}set ANDROID_DEVICE=<ip>:<port> to auto-connect${RESET}"
      fi
      ;;

    rust)
      local cargo_volume="claude-yolo-${hash}-cargo"
      local rustup_volume="claude-yolo-${hash}-rustup"
      local target_volume="claude-yolo-${hash}-target"

      docker_args+=(
        -v "${cargo_volume}:/home/claude/.cargo"
        -v "${rustup_volume}:/home/claude/.rustup"
        -v "${target_volume}:/workspace/target"
      )

      info "Worktree  ${display_worktree}"
      info "Rust · Cargo"
      ;;

    *)
      info "Worktree  ${display_worktree}"
      ;;
  esac

  # Chrome CDP MCP server
  if [[ "$chrome_mode" == true ]]; then
    ensure_chrome

    local mcp_config
    mcp_config=$(mktemp /tmp/claude-yolo-mcp-XXXXXX)
    cat > "$mcp_config" <<'MCPEOF'
{
  "mcpServers": {
    "chrome-devtools": {
      "command": "npx",
      "args": ["-y", "chrome-devtools-mcp@latest", "--browser-url=http://localhost:9222"]
    }
  }
}
MCPEOF
    docker_args+=(-v "${mcp_config}:/home/claude/.mcp.json:ro")
    info "Chrome CDP  ${DIM}MCP: chrome-devtools${RESET}"
  fi

  dim "→ Ctrl+C to exit │ cc --yolo to reconnect"

  docker_args+=(
    "${image_name}:latest"
    claude --dangerously-skip-permissions
  )

  # Append any extra claude args
  if [[ ${#claude_args[@]} -gt 0 ]]; then
    docker_args+=("${claude_args[@]}")
  fi

  info "Starting container ${DIM}${container_name}${RESET}"
  success "Launching Claude Code"
  footer
  exec "${docker_args[@]}"
}

attach_to_container() {
  local container_name="$1"
  shift
  local claude_args=("$@")

  local strategy="${container_name##*-}"
  local uptime
  uptime=$(container_uptime "$container_name" 2>/dev/null) || uptime="unknown"

  echo -e "  ${CYAN}↩${RESET} Container already running (strategy: ${BOLD}${strategy}${RESET}, up ${DIM}${uptime}${RESET})" >&2
  dim "→ Ctrl+C to exit │ cc --yolo to reconnect"
  success "Attaching"
  footer
  exec docker exec -it --user claude "$container_name" claude --dangerously-skip-permissions ${claude_args[@]+"${claude_args[@]}"}
}

########################################
# Main
########################################

main() {
  local yolo_mode=false
  local force_build=false
  local force_strategy=""
  local verbose=false
  local chrome_mode=false
  local claude_args=()

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --yolo)
        yolo_mode=true
        shift
        ;;
      --strategy)
        [[ $# -ge 2 ]] || { fail "--strategy requires an argument"; exit 1; }
        force_strategy="$2"
        shift 2
        ;;
      --build)
        force_build=true
        shift
        ;;
      --verbose)
        verbose=true
        shift
        ;;
      --chrome)
        chrome_mode=true
        shift
        ;;
      *)
        claude_args+=("$1")
        shift
        ;;
    esac
  done

  # Normal mode: pass through to native claude
  if [[ "$yolo_mode" == false ]]; then
    exec claude ${claude_args[@]+"${claude_args[@]}"}
  fi

  # YOLO mode
  check_docker
  header

  local worktree_path
  worktree_path=$(get_worktree_path)
  local hash
  hash=$(path_hash "$worktree_path")

  # Check for already-running container before running detection
  local running
  running=$(find_running_container "$hash" || true)
  if [[ -n "$running" ]]; then
    attach_to_container "$running" ${claude_args[@]+"${claude_args[@]}"}
    return $?
  fi

  # Choose strategy
  local strategy
  if [[ -n "$force_strategy" ]]; then
    strategy="$force_strategy"
    [[ -d "$STRATEGIES_DIR/$strategy" ]] || { fail "Unknown strategy: $strategy"; exit 1; }
    info "Using strategy: ${BOLD}${strategy}${RESET} (--strategy flag)"
  else
    strategy=$(choose_strategy "$worktree_path")
    if [[ "$strategy" == "__unknown__" ]]; then
      exit 0
    fi
    [[ -n "$strategy" ]] || { fail "No strategy selected"; exit 1; }
  fi

  # Ensure GitHub token for gh CLI inside container
  ensure_github_token "$worktree_path"

  # Force rebuild if requested
  if [[ "$force_build" == true ]]; then
    build_strategy_image "$strategy" "$verbose"
  fi

  local container_name="claude-yolo-${hash}-${strategy}"
  run_with_strategy "$strategy" "$container_name" "$verbose" ${claude_args[@]+"${claude_args[@]}"}
}

main "$@"
